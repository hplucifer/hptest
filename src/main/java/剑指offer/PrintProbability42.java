package 剑指offer;

public class PrintProbability42 {
    /*
    题43：把n个骰子仍在地上，所有的骰子朝上的一面的点数之和为s，输入n，打印出s所有可能的值出现的概率。
     */

    /**
     * 注意，是"所有可能的值"，就是全排列
     * n个骰子的问题实质就是一个动态规划问题，所以文本主要从动态规划的角度来求解这个问题。首先该问题具备DP的两个特征：最优子结构性质和子问题的重叠性。
     * 具体的表现在：(1)n个骰子的点数依赖于n-1个骰子的点数，相当于在n-1个骰子点数的基础上再进行投掷。(2)求父问题的同时，需要多次利用子问题。
     * 当有n个骰子，点数和为k时，出现次数记为f(n,k)
     * 当我有n-1个骰子时，再增加一个骰子，这个骰子的点数只可能为1、2、3、4、5或6。那n个骰子得到点数和为k的情况有：
     * (n-1,k-1)：第n个骰子投了点数1，即n-1个骰子投k-1次点数和为k-1；
     *
     * (n-1,k-2)：第n个骰子投了点数2
     *
     * (n-1,k-3)：第n个骰子投了点数3
     *
     * ....
     *
     * (n-1,k-6)：第n个骰子投了点数6
     *
     * 加上一个骰子，即n个骰子点数和为k的情况为上一次中n-1个骰子和为k-1。。。。。。k-6的次数的总和。
     *
     * 由此定义状态转移方程为𝑓(𝑛,𝑘)表示𝑛个骰子点数和为𝑘时出现的次数，于是可得:
     *
     * 𝑓(𝑛,𝑘)=𝑓(𝑛−1,𝑘−1)+𝑓(𝑛−1,𝑘−2)+𝑓(𝑛−1,𝑘−3)+𝑓(𝑛−1,𝑘−4)+𝑓(𝑛−1,𝑘−5)+𝑓(𝑛−1,𝑘−6)
     *
     * 其中 𝑛>0且𝑘<=6𝑛。其中𝑓(𝑛−1,𝑘−𝑖)表示的是第n次掷骰子时，骰子的点数为𝑖对应的情况，所以从𝑘−1到𝑘−6分别对应第n次掷骰子时骰子正面为1到6的情况。
     * 而初始状态可以定义为：
     *
     * 𝑓(1,1)=𝑓(1,2)=𝑓(1,3)=𝑓(1,4)=𝑓(1,5)=𝑓(1,6)=1
     */

     public static void printProbability(int n) {
         if (n <= 0) {
             return;
         }
         int totalNum = 0;
         //从arr[1][]开始，所以new要为n+1，不用管arr[0][]
         int[][] arr = new int[n + 1][6 * n + 1];//使用一个二维数组 dp 存储点数出现的次数，其中 dp[i][j] 表示前 i 个骰子产生点数 j 的次数。
         for (int i = 1; i <= 6; i++) {
             arr[1][i] = 1;
         }
         for (int i = 2; i <= n; i++) {
             for (int j = i; j <= 6 * i; j++) {
//                 arr[i][j] += (arr[i - 1][j - 1] + arr[i - 1][j - 2] + arr[i - 1][j - 3] + arr[i - 1][j - 4] +
//                         arr[i - 1][j - 5] + arr[i - 1][j - 6]);
                 //这样写，防止小于6时越界,这是本次投掷骰子1-6，j-k为本次投掷为k时，i-1个骰子投掷为j
                 for (int k = 1; k <= 6 && k < j; k++) {
                     arr[i][j] += arr[i - 1][j - k];
                 }
             }
         }

         for (int i = n; i <= 6 * n; i++) {
             totalNum += arr[n][i];
         }

         System.out.println(n + "个骰子总共的次数为" + totalNum);
         for(int i = n; i <= 6 * n; i++) {
             System.out.println("骰子的和为" + i + "频率" + (arr[n][i] * 1.0 / totalNum));
         }
     }
}
